<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ember Blog</title>
  <subtitle>Ember News and Updates</subtitle>
  <id>http://emberjs.com/blog</id>
  <link href="http://emberjs.com/blog"/>
  <link href="http://emberjs.com/blog/feed.xml" rel="self"/>
  <updated>2013-08-29T00:00:00Z</updated>
  <author>
    <name>Ember</name>
  </author>
  <entry>
    <title>Ember 1.0 RC8 Released</title>
    <link rel="alternate" href="/blog/2013/08/29/ember-1-0-rc8.html"/>
    <id>/blog/2013/08/29/ember-1-0-rc8.html</id>
    <published>2013-08-29T00:00:00Z</published>
    <updated>2013-08-29T00:00:00Z</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;With Ember 1.0 RC8, we have reached the final RC before 1.0 final, which
we hope to release this weekend if all goes well.&lt;/p&gt;

&lt;p&gt;This final release candidate comes with a couple of small breaking
changes that we are making before 1.0 because they should...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;With Ember 1.0 RC8, we have reached the final RC before 1.0 final, which
we hope to release this weekend if all goes well.&lt;/p&gt;

&lt;p&gt;This final release candidate comes with a couple of small breaking
changes that we are making before 1.0 because they should have a small
impact on application code but a large impact on performance.&lt;/p&gt;

&lt;p&gt;We normally would not make changes of this nature this close to the 1.0
final release date. However, the performance improvements were so
dramatic we did not want to wait until Ember.js 2.0 to introduce the
change, and we are serious in our commitment to not breaking the API
post-1.0. This was our last chance to get these changes in before
putting the final stamp on the 1.0.&lt;/p&gt;

&lt;p&gt;Both of the changes are related to observers. If you find yourself
writing code with lots of observers, you may be writing non-idiomatic
code. In general, you should only need to use observers when you are
bridging Ember code to other libraries that do not support bindings or
computed properties.&lt;/p&gt;

&lt;p&gt;For example, if you were writing a component that wrapped a jQuery UI
widget, you might use an observer to watch for changes on the component
and reflect them on to the widget.&lt;/p&gt;

&lt;p&gt;In your application code, however, you should be relying almost entirely
on computed properties.&lt;/p&gt;

&lt;p&gt;If you are having trouble upgrading your application, please join us in
the IRC channel or post on StackOverflow for help.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_declarative-event-listeners'&gt;Declarative Event Listeners&lt;/h4&gt;
&lt;p&gt;There is now a way to declaratively add event listeners to Ember
classes. This is easier than manually setting up the listeners in
&lt;code&gt;init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Instead of:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = DS.Model.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;didLoad&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="local-variable"&gt;this&lt;/span&gt;, &lt;span class="keyword"&gt;function&lt;/span&gt;() {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.finishedLoading();
    });
  },

  &lt;span class="function"&gt;finishedLoading&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// do stuff&lt;/span&gt;
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can just do this:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = DS.Model.extend({
  &lt;span class="function"&gt;finishedLoading&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// do stuff&lt;/span&gt;
  }.on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;didLoad&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_array-computed'&gt;Array Computed&lt;/h4&gt;
&lt;p&gt;Thanks to the tremendous work of David Hamilton, there is now a
convenient and robust way to build a computed property based on an array
that will only perform calculations on the updated portion.&lt;/p&gt;

&lt;p&gt;For example, say that you have an array of people, and you want to
create a computed property that returns an Array of their ages.&lt;/p&gt;

&lt;p&gt;Currently, the easiest way to do that is:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;childAges&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).mapProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children.@each.age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is pretty terse, but it must recalculate the entire array any time
a single element is added or removed. This works OK for small arrays,
but for larger arrays, or when these kinds of computed properties are
chained or doing expensive work, it can add up.&lt;/p&gt;

&lt;p&gt;Enter Array Computed properties:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;childAges&lt;/span&gt;: Ember.computed.mapProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can also chain these Array computed properties together:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;childAges&lt;/span&gt;: Ember.computed.mapProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;age&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),
  &lt;span class="key"&gt;maxChildAge&lt;/span&gt;: Ember.computed.max(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;childAges&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;When an element is added or removed, the computation is only done once.
In this example, if a child is added, their age is appended to
&lt;code&gt;childAges&lt;/code&gt;, and if that age is larger than the &lt;code&gt;maxChildAge&lt;/code&gt;, that
property is updated.&lt;/p&gt;

&lt;p&gt;These computed properties are always up to date, efficient, and
completely managed by Ember.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_ember-extension'&gt;Ember Extension&lt;/h4&gt;
&lt;p&gt;After months of testing, and tons of work by Teddy Zeenny, we&amp;#39;re finally
ready to put the Ember Inspector in the Chrome Web Store.&lt;/p&gt;

&lt;p&gt;Most recently, Teddy added support for loaded data. It already has
support for Ember Data, and Ember Model is actively working on adding
support.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-ember-data.png"&gt;&lt;/p&gt;

&lt;p&gt;Teddy has also significantly improved the object inspector, adding
support for objects to group properties as they wish (e.g. attributes,
has many, belongs to in Ember Data) and editing records in the inspector
itself.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-editing.png"&gt;&lt;/p&gt;

&lt;p&gt;You can also see a list of all routes in your app, along with the naming
you should use for associated objects. This should make remembering the
naming conventions a lot easier.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-routes.png"&gt;&lt;/p&gt;

&lt;p&gt;And finally, a view tree that shows an overlay in your app with the
associated controller and model for your application&amp;#39;s templates.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/rc8-view-tree.png"&gt;&lt;/p&gt;

&lt;p&gt;It should be in the web store in the next day or so, so keep an eye out.
Follow @emberjs on Twitter to get the latest!&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_release-cycle'&gt;Release Cycle&lt;/h4&gt;
&lt;p&gt;We know that the Ember 1.0 RC cycle was a &lt;strong&gt;bit&lt;/strong&gt; long. In truth, we
released RC1 too early. We&amp;#39;re sorry if the release names caused
confusion.&lt;/p&gt;

&lt;p&gt;Going forward, we plan to seriously tighten up our release process. We
will have a blog post outlining the new process together with the final
Ember 1.0 release.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_other-improvements'&gt;Other Improvements&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Several improvements to &lt;code&gt;yield&lt;/code&gt; to make sure it always yields back to
the calling context [@kselden]&lt;/li&gt;
&lt;li&gt;Performance improvement to range updates by not using the W3C range
API even if it&amp;#39;s available [@eviltrout]&lt;/li&gt;
&lt;li&gt;Completion of the 1.0 documentation audit [@trek]&lt;/li&gt;
&lt;li&gt;Better error message if you try to use the same template name multiple
times by using &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags [@locks]&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;currentRouteName&lt;/code&gt; to &lt;code&gt;ApplicationController&lt;/code&gt;, which you can use
in &lt;code&gt;link-to&lt;/code&gt;, &lt;code&gt;transitionTo&lt;/code&gt;, etc. [@machty]&lt;/li&gt;
&lt;li&gt;Alias &lt;code&gt;linkTo&lt;/code&gt; to &lt;code&gt;link-to&lt;/code&gt; and &lt;code&gt;bindAttr&lt;/code&gt; to &lt;code&gt;bind-attr&lt;/code&gt; for
consistency with HTML naming. Old names remain but are soft-deprecated
[@ebryn]&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class='anchorable-toc' id='toc_changes-tl-dr'&gt;Changes TL;DR&lt;/h4&gt;&lt;h5 class='anchorable-toc' id='toc_observers-don-t-fire-during-construction'&gt;Observers Don&amp;#39;t Fire During Construction&lt;/h5&gt;
&lt;p&gt;Previously, observers would not fire for properties passed into
&lt;code&gt;create&lt;/code&gt; or specified on the prototype, but they would fire if you &lt;code&gt;set&lt;/code&gt;
a property in &lt;code&gt;init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, observers &lt;strong&gt;never&lt;/strong&gt; fire until after &lt;code&gt;init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you need an observer to fire as part of the initialization process,
you can no longer rely on the side effect of &lt;code&gt;set&lt;/code&gt;. Instead, specify
that the observer should also run after &lt;code&gt;init&lt;/code&gt; by using
&lt;code&gt;.on(&amp;#39;init&amp;#39;)&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;salutation&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Mr/Ms&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
  },

  &lt;span class="function"&gt;salutationDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// some side effect of salutation changing&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;salutation&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;init&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h5 class='anchorable-toc' id='toc_unconsumed-computed-properties-do-not-trigger-observers'&gt;Unconsumed Computed Properties Do Not Trigger Observers&lt;/h5&gt;
&lt;p&gt;If you never &lt;code&gt;get&lt;/code&gt; a computed property, its observers will not fire even
if its dependent keys change. You can think of the value changing from
one unknown value to another.&lt;/p&gt;

&lt;p&gt;This doesn&amp;#39;t usually affect application code because computed properties
are almost always observed at the same time as they are fetched. For
example, you get the value of a computed property, put it in DOM (or
draw it with D3), and then observe it so you can update the DOM once the
property changes.&lt;/p&gt;

&lt;p&gt;If you need to observe a computed property but aren&amp;#39;t currently
retrieving it, just &lt;code&gt;get&lt;/code&gt; it in your &lt;code&gt;init&lt;/code&gt; method.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_new-actions-hash-for-routes-controllers-and-views'&gt;New Actions Hash for Routes, Controllers, and Views&lt;/h5&gt;
&lt;p&gt;Previously, you could define actions for your routes in their &lt;code&gt;events&lt;/code&gt; hash. In controllers and views however, actions were defined directly as methods on the instance. Not only was this inconsistent, it also lead to awkward naming conflicts. For instance, attempting to name your action &lt;code&gt;destroy&lt;/code&gt; would conflict with the built-in &lt;code&gt;destroy&lt;/code&gt; method and very bad things would happen.&lt;/p&gt;

&lt;p&gt;To make things consistent and give more flexibility in action naming, we&amp;#39;ve standardized around using a hash called &lt;code&gt;actions&lt;/code&gt;. When extending a class with &lt;code&gt;actions&lt;/code&gt; defined, we&amp;#39;ll merge the &lt;code&gt;actions&lt;/code&gt; defined on the subclass or instance with those on the parent. We also support &lt;code&gt;_super&lt;/code&gt; so you won&amp;#39;t lose any flexibility with this approach.&lt;/p&gt;

&lt;p&gt;The old behavior will continue to work for the time being but is now deprecated. In the event that you had a controller that was proxying to a model with an existing &lt;code&gt;actions&lt;/code&gt; property, we internally rename the property to &lt;code&gt;_actions&lt;/code&gt; to avoid any conflicts.&lt;/p&gt;
&lt;h5 class='anchorable-toc' id='toc_enforce-quoted-strings-in-handlebars-helpers'&gt;Enforce Quoted Strings in Handlebars Helpers&lt;/h5&gt;
&lt;p&gt;In the past, we were loose with our requirements for quoting strings in Handlebars helpers. Unfortunately, this meant we were unable to distinguish between string values and property paths. We are now strictly enforcing quoting if you want the value to be treated as a string. This means that for &lt;code&gt;link-to&lt;/code&gt; the route names must be quotes. In the reverse direction, if you had custom bound helpers and were passing a property path as a quoted string, this will no longer work. Again, quotes for strings, no quotes for paths.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_setting-properties-in-code-init-code'&gt;Setting Properties in &lt;code&gt;init&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Currently, there is an inconsistency between properties set when passing
a hash to &lt;code&gt;create&lt;/code&gt; and setting those same properties in &lt;code&gt;init&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// this observer does not fire&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

App.Person.create({ &lt;span class="key"&gt;firstName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tom&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Dale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case, because the properties were set by passing a hash to
&lt;code&gt;create&lt;/code&gt;, the observers are not fired.&lt;/p&gt;

&lt;p&gt;But let&amp;#39;s look at what happens in RC7 when the same initialization is
done via the &lt;code&gt;init&lt;/code&gt; method:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR&lt;/span&gt;

App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;if&lt;/span&gt; (!&lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)) {
      &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tom&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
    }
  },
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// this observer fires&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});

App.Person.create({ &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Dale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; });
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case, the old behavior would trigger the observers if
&lt;code&gt;firstName&lt;/code&gt; was not provided.&lt;/p&gt;

&lt;p&gt;We intended the design of the object model to trigger observers only
after construction, which is why &lt;code&gt;create&lt;/code&gt; behaves the way it does.&lt;/p&gt;

&lt;p&gt;Also, because the only way to define initial properties that have arrays
or objects as values is in &lt;code&gt;init&lt;/code&gt;, there is a further inconsistency:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR&lt;/span&gt;

App.Person = Ember.Object.extend({
  &lt;span class="comment"&gt;// initial property value, does not trigger an initialization observer&lt;/span&gt;
  &lt;span class="key"&gt;salutation&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Mr.&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,

  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// also initial property value, triggers an observer on&lt;/span&gt;
    &lt;span class="comment"&gt;// initialization&lt;/span&gt;
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;children&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, []);
  }
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In short, properties that get set during initialization, whether they
were already set on the prototype, passed as a hash to &lt;code&gt;create&lt;/code&gt;, or set
in &lt;code&gt;init&lt;/code&gt;, do not trigger observers.&lt;/p&gt;

&lt;p&gt;If you have some code that you want to run both on initialization and
when a property changes, just mark it as a method that should also run
when initialization is done by using &lt;code&gt;.on(&amp;#39;init&amp;#39;)&lt;/code&gt;. This will also be
more resiliant to refactoring, and not rely on a side effect of an
&lt;code&gt;init&lt;/code&gt;-time &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;firstNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="comment"&gt;// some side effect that happens when first name changes&lt;/span&gt;
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;).on(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;init&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_computed-property-performance-improvements'&gt;Computed Property Performance Improvements&lt;/h4&gt;
&lt;p&gt;The latest release of Ember.js contains a change to the way that observers and
computed properties interact. This may be a breaking change in apps that
relied on the previous behavior.&lt;/p&gt;

&lt;p&gt;To understand the change, let&amp;#39;s first look at an example of a computed
property.  Imagine we are trying to model &lt;a href="http://en.wikipedia.org/wiki/Schr%C3%B6dinger&amp;#x27;s_cat"&gt;Schrödinger&amp;#39;s famous
cat&lt;/a&gt; using an Ember.js
object.&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Cat = Ember.Object.extend({
  &lt;span class="function"&gt;isDead&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; Math.rand() &amp;gt; &lt;span class="float"&gt;0.5&lt;/span&gt;;
  }.property()
});

&lt;span class="keyword"&gt;var&lt;/span&gt; cat = App.Cat.create();
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Given this cat object, is it alive or is it dead? Well, that&amp;#39;s determined at random.
Before observing the cat, we might say that it&amp;#39;s &lt;em&gt;both&lt;/em&gt; alive &lt;em&gt;and&lt;/em&gt; dead, or
perhaps neither.&lt;/p&gt;

&lt;p&gt;In reality, whether or not our cat has shuffled off this mortal coil is only
determined the first time we ask for it:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;cat.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;isDead&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class="comment"&gt;// true&lt;/span&gt;
&lt;span class="comment"&gt;// …or false, half the time&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;After we have asked the cat object for its &lt;code&gt;isDead&lt;/code&gt; property, we can
categorically say which it is. But before we ask, the value of the
computed property doesn&amp;#39;t really &lt;em&gt;exist&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, let&amp;#39;s introduce observers into the mix. If the value of a computed
property doesn&amp;#39;t exist yet, should observers fire if one of its
dependent keys changes?&lt;/p&gt;

&lt;p&gt;In previous versions of Ember.js, the answer was &amp;quot;yes.&amp;quot; For example,
given this class:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="key"&gt;observerCount&lt;/span&gt;: &lt;span class="integer"&gt;0&lt;/span&gt;,

  &lt;span class="function"&gt;fullName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),

  &lt;span class="function"&gt;fullNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.incrementProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Changing any of the dependent keys would trigger the observer:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="comment"&gt;// WARNING: OLD BEHAVIOR DO NOT RELY ON THIS&lt;/span&gt;

&lt;span class="keyword"&gt;var&lt;/span&gt; person = App.Person.create({
  &lt;span class="key"&gt;firstName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Yehuda&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="key"&gt;lastName&lt;/span&gt;: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Katz&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
});

person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 0&lt;/span&gt;

person.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Tomhuda&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 1&lt;/span&gt;

person.set(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;span class="content"&gt;Katzdale&lt;/span&gt;&lt;span class="delimiter"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
person.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;); &lt;span class="comment"&gt;// =&amp;gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;However, because the &lt;code&gt;fullName&lt;/code&gt; property doesn&amp;#39;t really &amp;quot;exist&amp;quot; until
it&amp;#39;s requested, it is unclear if firing an observer is the correct
behavior.&lt;/p&gt;

&lt;p&gt;A related problem affects computed properties if their dependent
keys contain a path. (Remember that dependent keys are just the property
names you pass to &lt;code&gt;.property()&lt;/code&gt; when defining a CP.)&lt;/p&gt;

&lt;p&gt;For example, imagine we are building a model to represent a blog post
that lazily loads the post&amp;#39;s comments if they are used (in a template,
for instance).&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.BlogPost = Ember.Object.extend({
  &lt;span class="function"&gt;comments&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;var&lt;/span&gt; comments = [];
    &lt;span class="keyword"&gt;var&lt;/span&gt; url = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/post/&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);

    &lt;span class="predefined"&gt;$&lt;/span&gt;.getJSON(url).then(&lt;span class="keyword"&gt;function&lt;/span&gt;(data) {
      data.forEach(&lt;span class="keyword"&gt;function&lt;/span&gt;(comment) {
        comments.pushObject(comment);
      });
    });

    &lt;span class="keyword"&gt;return&lt;/span&gt; comments;
  }.property()
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Awesome! This will work as expected—a post&amp;#39;s comments will only be loaded
over the network the first time we do &lt;code&gt;post.get(&amp;#39;comments&amp;#39;)&lt;/code&gt; or use it
in a template:&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="tag"&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt; &lt;span class="attribute-name"&gt;comments&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
  &lt;span class="tag"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;title&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;each&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;span class="tag"&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;However, now we want to add a computed property that selects the first
comment from the array of loaded comments:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.BlogPost = Ember.Object.extend({
  &lt;span class="function"&gt;comments&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;var&lt;/span&gt; comments = [];
    &lt;span class="keyword"&gt;var&lt;/span&gt; url = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/post/&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;id&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/comments.json&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class="predefined"&gt;$&lt;/span&gt;.getJSON(url).then(&lt;span class="keyword"&gt;function&lt;/span&gt;(data) {
      data.forEach(&lt;span class="keyword"&gt;function&lt;/span&gt;(comment) {
        comments.pushObject(comment);
      });
    });

    &lt;span class="keyword"&gt;return&lt;/span&gt; comments;
  }.property(),

  &lt;span class="function"&gt;firstComment&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comments.firstObject&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;comments.firstObject&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now we have a problem! Because the &lt;code&gt;firstComment&lt;/code&gt; computed property has
a dependency on &lt;code&gt;comments.firstObject&lt;/code&gt;, it will &lt;code&gt;get()&lt;/code&gt; the &lt;code&gt;comments&lt;/code&gt;
property in order to set up an observer on &lt;code&gt;firstObject&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As you can see, just adding this computed property now means that the
comments are loaded for &lt;em&gt;all&lt;/em&gt; blog posts in the app—whether their
comments are ever used or not!&lt;/p&gt;

&lt;p&gt;To determine what to do, we spent some time looking at real-world
Ember.js apps. What we discovered is that &lt;strong&gt;this behavior carried with
it signficant performance penalties.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Firing observers on unmaterialized computed properties means we have
to set up listeners on all computed properties ahead of time, instead
of lazily the first time they are computed.&lt;/li&gt;
&lt;li&gt;Many computed properties that never get used are nonetheless computed
because of path dependent keys.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To fix these issues, &lt;strong&gt;RC8 makes the following changes&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Observers that observe a computed property only fire after that
property has been used at least once.&lt;/li&gt;
&lt;li&gt;Observing a path (&lt;code&gt;&amp;quot;foo.bar.baz&amp;quot;&lt;/code&gt;), or using a path as a dependent key,
will not cause any parts of the path that are uncomputed to become
computed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The majority of Ember.js applications should not be affected by this
change, since:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Most apps that observe computed properties also &lt;code&gt;get()&lt;/code&gt; those
properties at object initialization time, thus triggering the correct
behavior.&lt;/li&gt;
&lt;li&gt;In the case of computed property dependent keys, the new behavior is
what developers were expecting to happen all along.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If your applications are affected by this change, the fix is
straightforward: just &lt;code&gt;get()&lt;/code&gt; the computed property in your class&amp;#39;s
&lt;code&gt;init&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;For example, to update the observer example above, we can retain the
pre-RC8 behavior by &amp;quot;precomputing&amp;quot; the &lt;code&gt;fullName&lt;/code&gt; property:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9
&lt;strong&gt;10&lt;/strong&gt;
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Person = Ember.Object.extend({
  &lt;span class="function"&gt;init&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
    &lt;span class="local-variable"&gt;this&lt;/span&gt;._super();
  },

  &lt;span class="key"&gt;observerCount&lt;/span&gt;: &lt;span class="integer"&gt;0&lt;/span&gt;,

  &lt;span class="function"&gt;fullName&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="keyword"&gt;return&lt;/span&gt; &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;) + &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt; &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; + &lt;span class="local-variable"&gt;this&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.property(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;firstName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;lastName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;),

  &lt;span class="function"&gt;fullNameDidChange&lt;/span&gt;: &lt;span class="keyword"&gt;function&lt;/span&gt;() {
    &lt;span class="local-variable"&gt;this&lt;/span&gt;.incrementProperty(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;observerCount&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;);
  }.observes(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;fullName&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;)
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h4 class='anchorable-toc' id='toc_code-link-to-code-bound-parameters'&gt;&lt;code&gt;link-to&lt;/code&gt; Bound Parameters&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;link-to&lt;/code&gt; helper (formerly &lt;code&gt;linkTo&lt;/code&gt;, see above) now treats
all unquoted parameters (and non-numeric parameters)
as bound property paths, which means that when a property passed to
&lt;code&gt;link-to&lt;/code&gt; changes, the &lt;code&gt;href&lt;/code&gt; of the link will change. This includes
the first parameter (the destination route name) and any of the context
parameters that follow.&lt;/p&gt;

&lt;p&gt;The following example template will look up the &lt;code&gt;destinationRoute&lt;/code&gt; on the
current context (usually a controller) and use it to determine the
&lt;code&gt;href&lt;/code&gt; of the link and the route that will be transitioned to when
the link is clicked.&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt; &lt;span class="attribute-name"&gt;destinationRoute&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;Link Text&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The following example template will always point to the &lt;code&gt;articles.show&lt;/code&gt;
route (since the route name parameter is in quotes), but when the value
of &lt;code&gt;article&lt;/code&gt; changes, the link&amp;#39;s &lt;code&gt;href&lt;/code&gt; will update to the URL that
corresponds to the new value of &lt;code&gt;article&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{#&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;articles.show&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt; &lt;span class="attribute-name"&gt;article&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;Read More...&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{/&lt;/span&gt;&lt;span class="attribute-name"&gt;link-to&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This might cause a few surprises in your app if you haven&amp;#39;t been
distinguishing between quoted strings and property paths, so make sure
that any static string &lt;code&gt;link-to&lt;/code&gt; parameters (such as route names) are
properly quoted in your templates when you upgrade to RC8.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_bound-helpers-quoted-strings-numbers-and-paths'&gt;Bound Helpers: Quoted Strings, Numbers, and Paths&lt;/h4&gt;
&lt;p&gt;Invoking a custom bound helper (e.g. one defined via &lt;code&gt;Ember.Handlebars.helper&lt;/code&gt;)
with quoted strings or raw numbers will pass that raw value directly
into the helper function you&amp;#39;ve defined, rather than treating everything
like a bound property path that will re-render the helper when changed.&lt;/p&gt;
&lt;div class="highlight handlebars "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;Pass the string 'hello' to myHelper:
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;myHelper&lt;/span&gt; &lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="attribute-name"&gt;hello&lt;/span&gt;&lt;span class="error"&gt;'&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;

Pass the property pointed-to by the path 'hello' to myHelper:
&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;{{&lt;/span&gt;&lt;span class="attribute-name"&gt;myHelper&lt;/span&gt; &lt;span class="attribute-name"&gt;hello&lt;/span&gt;&lt;span class="inline-delimiter"&gt;}}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This might cause a few surprises in your app if you&amp;#39;ve been invoking
bound helpers with quoted strings and expecting them to be treated as
bound property paths, so make sure that the only time you&amp;#39;re passing
quoted strings to custom helpers is when you really intend to pass raw
strings (rather than the values of properties) to the helper.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.0 RC7 Released</title>
    <link rel="alternate" href="/blog/2013/08/14/ember-1-0-rc7.html"/>
    <id>/blog/2013/08/14/ember-1-0-rc7.html</id>
    <published>2013-08-14T00:00:00Z</published>
    <updated>2013-08-14T00:00:00Z</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;We’re pleased to announce the release of Ember 1.0 RC7 today! If all goes smoothly, this will be our penultimate RC before Ember 1.0.  This release includes a number of bug fixes and a few small improvements. We’ve got a few other bug fixes in the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;We’re pleased to announce the release of Ember 1.0 RC7 today! If all goes smoothly, this will be our penultimate RC before Ember 1.0.  This release includes a number of bug fixes and a few small improvements. We’ve got a few other bug fixes in the queue that weren’t quite ready but this release was overdue and we didn’t want to wait. To that end, we expect to release RC8 next week. Read on for more details on what we changed.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_important-changes'&gt;Important Changes&lt;/h3&gt;&lt;h4 class='anchorable-toc' id='toc_code-route-controllerfor-code-no-longer-auto-generates-controllers'&gt;&lt;code&gt;Route#controllerFor&lt;/code&gt; no longer auto generates controllers&lt;/h4&gt;
&lt;p&gt;In some cases, people have been relying on &lt;code&gt;controllerFor&lt;/code&gt; to access controllers for routes that have not yet been entered, relying on its auto-generation ability. Unfortunately, this can actually lead to subtle bugs. When entering a route, Ember looks for a controller with a matching name. If that controller isn’t found, Ember generates one according to the type of the route’s model. If the model is an array, we generate an &lt;code&gt;ArrayController&lt;/code&gt;; if it’s an object, an &lt;code&gt;ObjectController&lt;/code&gt;; if neither, a standard &lt;code&gt;Controller&lt;/code&gt;. In most cases, people using &lt;code&gt;controllerFor&lt;/code&gt; outside of the route are not providing a model and Ember will create the basic &lt;code&gt;Controller&lt;/code&gt;. If the route is later entered, the controller will not be re-created and the type of the controller may not match the provided model.&lt;/p&gt;

&lt;p&gt;Due to this, we removed the auto-generation abilities of &lt;code&gt;controllerFor&lt;/code&gt;. In most applications, this will not be an issue, but if you were relying on this behaviors, you will need to update your application. If you do have a controller that’s not associated with a route, you should explicitly define the controller&amp;#39;s class instead of relying on
auto generation.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_removed-code-old-router-code'&gt;Removed &lt;code&gt;old-router&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Ember’s old router was deprecated prior to the first RC and while it’s never been included in standard RC builds, some users have still been relying on it. Despite this, it’s become time to cut the ties. Increasingly, new features we are adding, especially containers, are incompatible with the old router. Because of this, we’ve removed the old router code from Ember’s repo and you are no longer able to make custom Ember builds with it. We strongly encourage everyone still using the old router to upgrade. However, if anyone is interested in maintaining an old router library independent of the main Ember repo, please let us know.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_other-changes'&gt;Other changes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Update Handlebars version to 1.0.0&lt;/strong&gt; — Handlebars 1.0.0 was released almost simultaneously with RC6. Unfortunately, we hadn’t upgraded Ember to support it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;mergedProperties&lt;/code&gt; — Similar to &lt;code&gt;concatenatedProperties&lt;/code&gt; but for objects. It merges the properties of the two basic objects into a single object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Deprecate &lt;code&gt;template&lt;/code&gt; in favor of &lt;code&gt;partial&lt;/code&gt;&lt;/strong&gt; — There was a lot of overlap between these two methods. We’ve solidified around &lt;code&gt;partial&lt;/code&gt; and no longer require an underscore-prefixed name.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Update Backburner.js (Ember’s RunLoop) - fixes &lt;code&gt;debounce&lt;/code&gt; adds &lt;code&gt;throttle&lt;/code&gt;&lt;/strong&gt; — Previously, &lt;code&gt;Ember.run.debounce&lt;/code&gt; actually performed throttling. &lt;code&gt;debounce&lt;/code&gt; now actually performs a debounce and the thottling behavior has been moved to &lt;code&gt;Ember.run.throttle&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Routes can now specify their controller class name with &lt;code&gt;controllerName&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add &lt;code&gt;Ember.Route#disconnectOutlet&lt;/code&gt;, to allow for clearing a previously rendered outlet.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added functionality to Router.map to allow it to be called multiple times without the map being overwritten. Allows routes to be added at runtime.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;UPDATE:&lt;/em&gt; The post previously recommended the use of &lt;code&gt;Route#generateController&lt;/code&gt; for cases where the controller was not associated with a route. We are now directing users to just explicitly declare the controller&amp;#39;s class instead of relying on generation.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.0 RC6.1, RC5.1, RC4.1, RC3.1, RC2.1 RC1.1 Released</title>
    <link rel="alternate" href="/blog/2013/07/25/ember-1-0-rc6-1-rc5-1-rc4-1-rc3-1-rc2-1-and-rc1-1-released.html"/>
    <id>/blog/2013/07/25/ember-1-0-rc6-1-rc5-1-rc4-1-rc3-1-rc2-1-and-rc1-1-released.html</id>
    <published>2013-07-25T00:00:00Z</published>
    <updated>2013-07-25T00:00:00Z</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Because many Ember.js apps allow users to interact with private data, we
take security issues very seriously.&lt;/p&gt;

&lt;p&gt;In fact, we're one of the few JavaScript projects that has a
&lt;a href="http://emberjs.com/security/"&gt;clearly outlined security policy&lt;/a&gt; and a
&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;low-traffic mailing list exclusively...&lt;/a&gt;&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Because many Ember.js apps allow users to interact with private data, we
take security issues very seriously.&lt;/p&gt;

&lt;p&gt;In fact, we&amp;#39;re one of the few JavaScript projects that has a
&lt;a href="http://emberjs.com/security/"&gt;clearly outlined security policy&lt;/a&gt; and a
&lt;a href="https://groups.google.com/forum/#!forum/ember-security"&gt;low-traffic mailing list exclusively for security
announcements&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We want developers to know that they can trust Ember enough to build
their businesses on top of it.&lt;/p&gt;

&lt;p&gt;In that spirit, today we are announcing the release of Ember.js 1.0
RC6.1, RC5.1, RC4.1, RC3.1, RC2.1 and RC1.1. These are all security
releases that address a potential XSS security issue you can learn more
about by following this link:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://groups.google.com/forum/#!topic/ember-security/dokLVwwxAdM"&gt;CVE-2013-4170&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is recommended that you update immediately. In order to ease
upgrading, the only major change in each release is the security fix.&lt;/p&gt;

&lt;p&gt;We would like to thank Mario Heiderich of &lt;a href="https://cure53.de/"&gt;Cure53&lt;/a&gt;
for responsibly disclosing this issue, working with us on the patch
and the advisory, and having patience while we went through our
security procedure for the first time.&lt;/p&gt;

&lt;p&gt;Like a smoke detector or fire extinguisher, having a security procedure
is something that you hope that you don&amp;#39;t need; but when you need it,
you&amp;#39;re glad you have it.&lt;/p&gt;

&lt;p&gt;We hope that we can set an example for other projects in the JavaScript
world when it comes to taking security seriously. Initiatives like the
&lt;a href="https://nodesecurity.io/"&gt;Node Security Project&lt;/a&gt; are a step in the
right direction.&lt;/p&gt;

&lt;p&gt;We are very fortunate that this security issue is low severity. Due to
the sandboxed nature of the web browser, there are far fewer possible
exploit vectors for a JavaScript MVC framework to worry about than a
traditional server-side framework.&lt;/p&gt;

&lt;p&gt;That being said, we will remain vigilant in ensuring that even small
security issues are taken care of properly. If you discover what you
believe may be a security issue in Ember.js, we ask that you follow
our &lt;a href="http://emberjs.com/security/"&gt;responsible disclosure policy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lastly, thanks to Yehuda Katz, Stefan Penner and Kris Selden, who
donated their valuable time to reviewing the patch, auditing other code
for similar vulnerabilities, and preparing the new releases.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.0 RC6</title>
    <link rel="alternate" href="/blog/2013/06/23/ember-1-0-rc6.html"/>
    <id>/blog/2013/06/23/ember-1-0-rc6.html</id>
    <published>2013-06-23T00:00:00Z</published>
    <updated>2013-06-23T00:00:00Z</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember.js 1.0 RC6 has been released and is available from the
main website and at &lt;a href="http://builds.emberjs.com"&gt;builds.emberjs.com&lt;/a&gt;.  This
release features two big changes: 1) router update 2) Ember Components.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Router Update&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The biggest change is router update (aka "router facelift...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Ember.js 1.0 RC6 has been released and is available from the
main website and at &lt;a href="http://builds.emberjs.com"&gt;builds.emberjs.com&lt;/a&gt;.  This
release features two big changes: 1) router update 2) Ember Components.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Router Update&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The biggest change is router update (aka &amp;quot;router facelift&amp;quot;), which addresses
two major issues. The first was inconsistent semantics between URL-based transitions
and &lt;code&gt;transitionTo&lt;/code&gt;. The second was spotty async support which made it difficult to
prevent or delay route entry in cases such as authentication and async code-loading.&lt;/p&gt;

&lt;p&gt;We have now harmonized URL changes and &lt;code&gt;transitionTo&lt;/code&gt; semantics and more fully embraced
asynchrony using promises.&lt;/p&gt;

&lt;p&gt;Additionally, router transitions have become first-class citizens and there are
new hooks to prevent or decorate transitions:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;willTransition&lt;/code&gt;: fires on current routes whenever a transition is about to take place
 &lt;code&gt;beforeModel&lt;/code&gt;/&lt;code&gt;model&lt;/code&gt;/&lt;code&gt;afterModel&lt;/code&gt;: hooks fired during the async validation phase&lt;/p&gt;

&lt;p&gt;Finally there is an &lt;code&gt;error&lt;/code&gt; event which fires whenever there is a rejected promise or
error thrown in any of the &lt;code&gt;beforeModel&lt;/code&gt;/&lt;code&gt;model&lt;/code&gt;/&lt;code&gt;afterModel&lt;/code&gt; hooks.&lt;/p&gt;

&lt;p&gt;For more on new router features, see:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://machty.s3.amazonaws.com/ember-facelift-presentation/index.html#/1"&gt;New router overview given by Alex Matchneer&amp;#39;s at the June Ember NYC Meetup &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/machty/5647589"&gt;Usage Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.embercasts.com/episodes/client-side-authentication-part-2"&gt;Client-side Authentication Part 2 Embercast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Special thanks to Alex Matchneer for his work on this!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Ember Components&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The other major change is the introduction of Ember Components, which shares Web
Components&amp;#39; goal of facilitating creation of reusable higher-level page elements.&lt;/p&gt;

&lt;p&gt;Ember Components will generally consist of a &lt;code&gt;template&lt;/code&gt; and a &lt;code&gt;view&lt;/code&gt; which encapsulate the &lt;code&gt;template&lt;/code&gt;&amp;#39;s
property access and actions.  Any reference to outside constructs is handled through context
info passed into the &lt;code&gt;view&lt;/code&gt;.  Components can be customized through subclassing.&lt;/p&gt;

&lt;p&gt;Ember Components naming conventions are: 1) the &lt;code&gt;template&lt;/code&gt;&amp;#39;s name begins with &amp;#39;components/&amp;#39;, and 2) the
Component&amp;#39;s name must include a &amp;#39;-&amp;#39; (this latter convention is consistent with Web Components standards,
and prevents name collisions with built-in controls that wrap HTML elements). As an example, a component
might be named &lt;code&gt;&amp;#39;radio-button&amp;#39;&lt;/code&gt;.  Its &lt;code&gt;template&lt;/code&gt; would be &lt;code&gt;&amp;#39;components/radio-button&amp;#39;&lt;/code&gt; and you would call
it as &lt;code&gt;{{radio-button}}&lt;/code&gt; in other &lt;code&gt;templates&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Stay tuned for more docs and examples of this exciting new feature.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember 1.0 RC5</title>
    <link rel="alternate" href="/blog/2013/06/01/ember-1-0-rc5.html"/>
    <id>/blog/2013/06/01/ember-1-0-rc5.html</id>
    <published>2013-06-01T00:00:00Z</published>
    <updated>2013-06-01T00:00:00Z</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Ember.js 1.0 RC5 has just been released and is now available from the
main website as well as &lt;a href="http://builds.emberjs.com"&gt;builds.emberjs.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;RC5 fixes several regressions and bugs found in RC4. Notably:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A performance regression caused by a change to run loop scheduling has...&lt;/li&gt;
&lt;/ul&gt;</summary>
    <content type="html">&lt;p&gt;Ember.js 1.0 RC5 has just been released and is now available from the
main website as well as &lt;a href="http://builds.emberjs.com"&gt;builds.emberjs.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;RC5 fixes several regressions and bugs found in RC4. Notably:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A performance regression caused by a change to run loop scheduling has
been fixed. Thanks to &lt;a href="https://twitter.com/ebryn"&gt;Erik Bryn&lt;/a&gt; for
working on this.&lt;/li&gt;
&lt;li&gt;Promises returned from a route&amp;#39;s &lt;code&gt;model&lt;/code&gt; hook could cause the app to
hang on page refresh. This has been fixed thanks to &lt;a href="https://twitter.com/machty"&gt;Alex Matchneer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ember-testing&lt;/code&gt; package, which contains additional helpers for
testing Ember.js apps, is no longer included in the production build.
This means less JavaScript for end users to load over the network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thank you to everyone who filed issues and pull requests. Please try out
RC5 in your applications and report any issues or regressions you find
by filing an &lt;a href="https://github.com/emberjs/ember.js/issues"&gt;issue on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lastly, thanks to &lt;a href="https://twitter.com/stefanpenner"&gt;Stefan Penner&lt;/a&gt;, who
has been busting his tail to get Ember.js to the 1.0 finish line,
including doing the release engineering for these release candidates.
Thanks Stef!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ember Data 0.13</title>
    <link rel="alternate" href="/blog/2013/05/28/ember-data-0-13.html"/>
    <id>/blog/2013/05/28/ember-data-0-13.html</id>
    <published>2013-05-28T00:00:00Z</published>
    <updated>2013-05-28T00:00:00Z</updated>
    <author>
      <name>Ember</name>
    </author>
    <summary type="html">&lt;p&gt;Today, we are pleased to announce the release of Ember Data 0.13.&lt;/p&gt;

&lt;p&gt;Ember Data 0.13 is the first official release of Ember Data. This should
make it easier for people to synchronize Ember.js and Ember Data
versions, and make reasoning about the upgrade...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;Today, we are pleased to announce the release of Ember Data 0.13.&lt;/p&gt;

&lt;p&gt;Ember Data 0.13 is the first official release of Ember Data. This should
make it easier for people to synchronize Ember.js and Ember Data
versions, and make reasoning about the upgrade process much easier.&lt;/p&gt;
&lt;h3 class='anchorable-toc' id='toc_ember-data-0-13'&gt;Ember Data 0.13&lt;/h3&gt;
&lt;p&gt;In the past few months, Ember Data has stabilized a lot. We still consider
it alpha, and recommend it for production use only to those who like to
live on the bleeding edge and contribute back to the project. To make life
easier for those folks, though, we will be cutting regular releases like we
do with Ember.js.&lt;/p&gt;

&lt;p&gt;A few of the many folks involved in the changes in this release include
Tom Dale, Yehuda Katz, Cyril Fluck, Igor Terzic, Stefan Penner, Paul Chavard,
Gordon Hempton, Peter Wagenet. Thank you to you all and everyone else who
has contributed code and others.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_api-revision-removal'&gt;API Revision Removal&lt;/h4&gt;
&lt;p&gt;Now that we are doing regular releases, the API revision check has been
removed. You no longer need to provide the API revision number when
defining your store:&lt;/p&gt;
&lt;div class="highlight js "&gt;&lt;div class="ribbon"&gt;&lt;/div&gt;&lt;div class="scroller"&gt;&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers"&gt;&lt;pre&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;App.Store = DS.Store.extend({
  &lt;span class="comment"&gt;// Delete this!&lt;/span&gt;
  &lt;span class="key"&gt;revision&lt;/span&gt;: &lt;span class="integer"&gt;13&lt;/span&gt;
});
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;h3 class='anchorable-toc' id='toc_ember-data-future-plans'&gt;Ember Data Future Plans&lt;/h3&gt;
&lt;p&gt;Our immediate goals for Ember Data are stabilization, bug fixes, and
documentation. There are only two major areas of improvement planned
before we beging promoting builds to prerelease and RC versions:&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_promises'&gt;Promises&lt;/h4&gt;
&lt;p&gt;Currently, most Ember Data APIs return objects that also implement a
&lt;code&gt;then()&lt;/code&gt; method, allowing them to be used interchangeably as either
models or promises.&lt;/p&gt;

&lt;p&gt;While this flexibility was convenient, it unfortunately caused confusing
semantics. Specifically, because a resolved promise stays resolved,
operations like reloading became very confusing.&lt;/p&gt;

&lt;p&gt;While not in this release, you should expect that future releases of
Ember Data will shift to an entirely promise-based API. This both
resolves the issues with confusing semantics as well as allows us to
implement some exciting features, like more powerful polymorphism.&lt;/p&gt;

&lt;p&gt;Thanks to Stefan Penner for leading the charge on this.&lt;/p&gt;
&lt;h4 class='anchorable-toc' id='toc_error-handling'&gt;Error Handling&lt;/h4&gt;
&lt;p&gt;We want to make error handling and dealing with client and server
conflicts rock solid. A &lt;a href="https://github.com/emberjs/data/pull/958"&gt;pull request from Paul Chavard&lt;/a&gt;
is currently open and looks like a solid starting point for error
handling. You should see much more development on this in the near
future.&lt;/p&gt;
</content>
  </entry>
</feed>
